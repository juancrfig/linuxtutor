#!/bin/bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DevOps Bootcamp Simulator
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 30 realistic production scenarios
# Finish all 30 â†’ you're job-ready
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROGRESS_FILE="$SCRIPT_DIR/progress/bootcamp-progress.json"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# Initialize progress if needed
if [[ ! -f "$PROGRESS_FILE" ]]; then
    mkdir -p "$(dirname "$PROGRESS_FILE")"
    cat > "$PROGRESS_FILE" << 'END'
{
  "started": null,
  "current_day": 1,
  "completed": [],
  "skipped": [],
  "notes": {}
}
END
fi

get_progress() {
    python3 -c "import json; print(json.load(open('$PROGRESS_FILE'))['current_day'])"
}

mark_complete() {
    local day=$1
    python3 << END
import json
with open('$PROGRESS_FILE', 'r') as f:
    data = json.load(f)
if $day not in data['completed']:
    data['completed'].append($day)
data['current_day'] = $day + 1
with open('$PROGRESS_FILE', 'w') as f:
    json.dump(data, f, indent=2)
END
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SCENARIO LIBRARY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

scenario_01_intro() {
    clear
    cat << "EOF"
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘            DAY 1: WELCOME TO FAKECORP                    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Monday, 9:00 AM. Your first day as a DevOps intern at FakeCorp.

Your manager hands you a laptop and says: "The senior engineer 
is on vacation for a month. You're on-call. Don't break production."

Slack notification: "Hey, the nginx server isn't starting. Can you look?"

You SSH into web-prod-01. Time to prove yourself.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
INTERVIEW QUESTION:

What's the first command you run when troubleshooting a 
service that won't start?

> Your answer (write it down): _____________________________

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
HANDS-ON TASK:

1. Check if nginx is running
2. If not, check why it failed to start
3. Read the last 20 lines of nginx logs
4. Start nginx successfully

EOF

    read -p "Press Enter when you've completed all tasks..."
    
    cat << "EOF"
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SELF-CHECK:

Did you run:
âœ“ systemctl status nginx (or service nginx status)
âœ“ journalctl -u nginx (or check /var/log/nginx/)
âœ“ systemctl start nginx

Common mistakes:
âœ— Jumping straight to "sudo reboot"
âœ— Editing config files before checking logs
âœ— Not checking if it's a port conflict

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
EOF

    echo ""
    read -p "Did you solve it? (y/n): " solved
    if [[ "$solved" == "y" ]]; then
        mark_complete 1
        echo -e "${GREEN}Day 1 complete! âœ…${NC}"
    else
        echo -e "${YELLOW}Review the self-check and try again.${NC}"
    fi
}

scenario_02_disk_full() {
    clear
    cat << "EOF"
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘          DAY 2: THE DISK SPACE DISASTER                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Tuesday, 8:47 AM. PagerDuty wakes you up.

Alert: "Disk usage on app-server-03 at 98%"

The app team is panicking. Deployments are failing. 
Database writes are timing out. Everything is slow.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
INTERVIEW QUESTION:

A filesystem shows 90% full but 'du' totals only 40%. 
What could cause this discrepancy and how do you find it?

> Your answer: _____________________________________________

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
HANDS-ON TASK:

1. Find which filesystem is full
2. Identify the top 5 largest directories
3. Find files deleted but still held open by processes
4. Free up at least 10GB of space

Tip: Check /var/log first. Old logs are often the culprit.

EOF

    read -p "Press Enter when done..."
    
    cat << "EOF"
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SELF-CHECK:

Key commands you should've used:
âœ“ df -h (overview)
âœ“ du -sh /* | sort -hr (find large dirs)
âœ“ lsof | grep deleted (phantom files)
âœ“ journalctl --vacuum-size=500M (clean systemd logs)

Did you remember to rotate logs, not just delete them?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
EOF

    echo ""
    read -p "Solved? (y/n): " solved
    [[ "$solved" == "y" ]] && mark_complete 2 && echo -e "${GREEN}Day 2 complete! âœ…${NC}"
}

scenario_03_permission_denied() {
    clear
    cat << "EOF"
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘        DAY 3: PERMISSION DENIED NIGHTMARE                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Wednesday, 10:15 AM. A developer DMs you:

"I can't deploy the new build. Getting 'Permission denied' 
when the script tries to write to /var/www/html. I checked â€” 
the directory exists and I'm in the web-deployers group!"

You check. He IS in the group. The directory IS owned by 
web-deployers. So why can't he write?

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
INTERVIEW QUESTION:

A user is in the correct group, the directory has group write 
permissions (775), but they still can't create files. What are 
three possible causes?

> Your answer: _____________________________________________

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
HANDS-ON TASK:

1. Verify the user's group membership
2. Check directory permissions AND ownership
3. Check parent directory permissions
4. Look for SELinux/AppArmor denials
5. Fix it so deploys work

EOF

    read -p "Press Enter when fixed..."
    
    cat << "EOF"
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SELF-CHECK:

Did you check:
âœ“ groups username (current groups)
âœ“ id username (all group info)
âœ“ ls -ld /var/www/html (dir permissions)
âœ“ namei -l /var/www/html (full path permissions)
âœ“ getenforce (SELinux status)

Common gotcha: User needs to log out/in after group changes!
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
EOF

    echo ""
    read -p "Fixed it? (y/n): " solved
    [[ "$solved" == "y" ]] && mark_complete 3 && echo -e "${GREEN}Day 3 complete! âœ…${NC}"
}

scenario_04_zombie_process() {
    clear
    cat << "EOF"
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         DAY 4: THE ZOMBIE APOCALYPSE                     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Thursday, 2:00 PM. Monitoring shows something weird:

"378 zombie processes on batch-worker-05"

The server isn't slow YET, but it's creeping up. You need 
to find out what's spawning zombies and stop it before it 
cascades into a full outage.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
INTERVIEW QUESTION:

What IS a zombie process? Why do they happen? Can you kill 
them with 'kill -9'? If not, how do you clean them up?

> Your answer: _____________________________________________

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
HANDS-ON TASK:

1. List all zombie processes
2. Find their parent process (PPID)
3. Identify what the parent is doing wrong
4. Decide: restart the parent or reboot the server?
5. Clean up the zombies

EOF

    read -p "Press Enter when zombies are gone..."
    
    cat << "EOF"
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SELF-CHECK:

Key commands:
âœ“ ps aux | grep 'Z' (find zombies)
âœ“ ps -o ppid= -p <zombie-pid> (get parent)
âœ“ kill -HUP <parent-pid> (signal parent to reap children)

Remember: You can't kill zombies directly. Fix the parent!
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
EOF

    echo ""
    read -p "Zombies cleaned? (y/n): " solved
    [[ "$solved" == "y" ]] && mark_complete 4 && echo -e "${GREEN}Day 4 complete! âœ…${NC}"
}

scenario_05_port_conflict() {
    clear
    cat << "EOF"
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           DAY 5: PORT ALREADY IN USE                     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Friday, 9:30 AM. You try to start the new microservice:

$ sudo systemctl start api-gateway
Job for api-gateway.service failed. See 'systemctl status'

Logs show: "Error: bind EADDRINUSE: address already in use :::8080"

Something else is squatting on port 8080. Find it. Kill it. 
Deploy the new service.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
INTERVIEW QUESTION:

How do you find which process is listening on a specific port? 
Give at least two different commands.

> Your answer: _____________________________________________

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
HANDS-ON TASK:

1. Find what's using port 8080
2. Identify if it's supposed to be running
3. Stop it gracefully (or kill if orphaned)
4. Start api-gateway successfully
5. Verify it's listening on 8080

EOF

    read -p "Press Enter when api-gateway is running..."
    
    cat << "EOF"
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SELF-CHECK:

Did you use:
âœ“ ss -tlnp | grep 8080
âœ“ netstat -tlnp | grep 8080 (legacy but still common)
âœ“ lsof -i :8080
âœ“ Checked the PID and process name before killing

Pro tip: Always check if it's a legit service before killing!
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
EOF

    echo ""
    read -p "Gateway running? (y/n): " solved
    [[ "$solved" == "y" ]] && mark_complete 5 && echo -e "${GREEN}Day 5 complete! Week 1 done! ðŸŽ‰${NC}"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN MENU
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

show_menu() {
    clear
    cat << "EOF"
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘        DevOps Bootcamp Simulator v1.0                   â•‘
â•‘                                                          â•‘
â•‘  30 Days of Production Incidents                        â•‘
â•‘  Finish all â†’ Job Ready                                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

EOF

    local current=$(get_progress)
    local completed=$(python3 -c "import json; print(len(json.load(open('$PROGRESS_FILE'))['completed']))")
    
    echo -e "${CYAN}Progress: $completed/30 scenarios completed${NC}"
    echo -e "${CYAN}Current: Day $current${NC}"
    echo ""
    echo "Options:"
    echo "  1. Start Day $current"
    echo "  2. Jump to specific day"
    echo "  3. View progress"
    echo "  4. Reset progress"
    echo "  5. Exit"
    echo ""
    read -p "Choose [1-5]: " choice
    
    case "$choice" in
        1) run_scenario "$current" ;;
        2) 
            read -p "Which day (1-30)? " day
            if [[ "$day" =~ ^[0-9]+$ ]] && [[ "$day" -ge 1 ]] && [[ "$day" -le 30 ]]; then
                run_scenario "$day"
            else
                echo "Invalid day number"
                sleep 2
            fi
            ;;
        3) show_progress ;;
        4) reset_progress ;;
        5) exit 0 ;;
        *) show_menu ;;
    esac
}

run_scenario() {
    local day=$1
    case $day in
        1) scenario_01_intro ;;
        2) scenario_02_disk_full ;;
        3) scenario_03_permission_denied ;;
        4) scenario_04_zombie_process ;;
        5) scenario_05_port_conflict ;;
        *) 
            echo -e "${YELLOW}Day $day scenario not yet implemented.${NC}"
            echo "Check back soon â€” more scenarios coming!"
            sleep 3
            ;;
    esac
    show_menu
}

show_progress() {
    clear
    echo -e "${BOLD}${CYAN}Bootcamp Progress${NC}"
    echo ""
    python3 << 'END'
import json
with open('progress/bootcamp-progress.json') as f:
    data = json.load(f)
print(f"Completed: {len(data['completed'])}/30")
print(f"Next up: Day {data['current_day']}")
print("")
if data['completed']:
    print("Completed scenarios:")
    for day in sorted(data['completed']):
        print(f"  âœ“ Day {day}")
END
    echo ""
    read -p "Press Enter to continue..."
    show_menu
}

reset_progress() {
    echo -e "${RED}This will erase all progress. Are you sure? (yes/no)${NC}"
    read -p "> " confirm
    if [[ "$confirm" == "yes" ]]; then
        cat > "$PROGRESS_FILE" << 'END'
{
  "started": null,
  "current_day": 1,
  "completed": [],
  "skipped": [],
  "notes": {}
}
END
        echo -e "${GREEN}Progress reset.${NC}"
        sleep 2
    fi
    show_menu
}

# Start
show_menu
