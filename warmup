#!/usr/bin/env bash
set -euo pipefail

# ────────────────────────────────────────────────────────────────
# CONFIGURATION
# ────────────────────────────────────────────────────────────────

SANDBOX="$HOME/sandbox"
mkdir -p "$SANDBOX/day1"
cd "$SANDBOX" || exit 1

# ────────────────────────────────────────────────────────────────
# INTRO – MAN PAGES & SELF-RELIANCE
# ────────────────────────────────────────────────────────────────

clear
cat << "EOF"
=============================================
WELCOME TO THE LINUX DAILY WARM-UP
=============================================

Good morning. As you know, AI created Skynet some years ago and humankind had
to ban it. We need to make sure you don't need it to perform. 
It's only allowed for Senior engineers.

We do NOT Google or ask AI for commands.
We use the tools the system gives us.

Prove you can find and read information yourself without exiting the terminal 
while solving the following challenges, and you will get the job. 
Fail, and you're out.
EOF

echo
read -p "Press Enter to accept the challenge and begin..."

clear
cat << "EOF"
Before we throw real tasks at you, two quick tools you must master.
These are how every good engineer finds and understands commands.

1. Finding unknown commands: apropos (or man -k)

   apropos searches the short descriptions of all installed man pages.

   Examples:
     apropos network
     apropos "list contents"

2. Reading man pages: man <command>

   Inside a man page:
   ────────────────────────────────────────────────────────────────
   Key                  Action
   ────────────────────────────────────────────────────────────────
   Space or f           Move forward one full screen
   b                    Move backward one full screen
   j                    Move down one line
   k                    Move up one line
   h                    Move to the left
   l                    Move to the right
   /word                Search forward for 'word'
   ?word                Search backward for 'word'
   n                    Jump to next search match
   N                    Jump to previous search match
   g                    Jump to the very top of the page
   G                    Jump to the very bottom
   ────────────────────────────────────────────────────────────────
EOF

echo
read -p "Press Enter to continue..."

clear
cat << "EOF"
Excellent. You now know:
- How to find almost any command
- How to navigate and quickly extract useful info from man pages

That's already a massive edge over most beginners.

Let's get to real work.
EOF

echo
read -p "Press Enter to continue..."

# ────────────────────────────────────────────────────────────────
# SETUP – CONNECT TO YOUR WORKSTATION
# ────────────────────────────────────────────────────────────────

clear
cat <<EOF
═══════════════════════════════════════════════════════════════
                    KUBECRAFT ONBOARDING
═══════════════════════════════════════════════════════════════

Welcome, engineer. Before you touch production systems,
you need a proper workspace.

Your workstation is waiting at: 192.168.1.100
User: engineer

First: Connect via SSH and set up your environment.
EOF

read -p "Press Enter when ready..."

# ────────────────────────────────────────────────────────────────
# SSH Setup Task
# ────────────────────────────────────────────────────────────────
clear
cat <<EOF
SETUP TASK 1/2: SSH Connection
───────────────────────────────

Your workstation is at 192.168.1.100

1. SSH into the server as user 'engineer'
2. Check the OS version (hint: /etc/os-release)
3. Verify you can run commands remotely without logging in:
   ssh engineer@192.168.1.100 "whoami"

When connected and verified,
press Enter...
EOF

read -p ""

# ────────────────────────────────────────────────────────────────
# Tmux Setup Task
# ────────────────────────────────────────────────────────────────
clear
cat <<EOF
SETUP TASK 2/2: Terminal Multiplexer
─────────────────────────────────────

You'll be monitoring logs, editing configs, and running commands.
Do it all from one terminal with tmux.

1. Install tmux on the remote server
2. Create a new session named 'work'
3. Split the window vertically (two panes side by side)
4. In the left pane: watch system uptime
5. In the right pane: watch active network connections
6. Detach from the session (keep it running)
7. List all tmux sessions
8. Re-attach to your 'work' session

When your workspace is persistent and organized,
press Enter...
EOF

read -p ""

clear
cat <<EOF
═══════════════════════════════════════════════════════════════
                    WORKSPACE READY
═══════════════════════════════════════════════════════════════

You now have:
✓ SSH access to your workstation
✓ Persistent tmux session for multitasking

You're ready for real work.

Remember: Detach with Ctrl+b d, re-attach anytime with:
  tmux attach -t work

Press Enter to begin Day 1...
EOF

read -p ""

# ────────────────────────────────────────────────────────────────
# DAY 1 – FIRST MORNING AS KUBECRAFT INTERN
# ────────────────────────────────────────────────────────────────

# ────────────────────────────────────────────────────────────────
# Task 1
# ────────────────────────────────────────────────────────────────
clear
cat <<EOF
Task 1/9
─────────

Before you touch anything, find out who you really are
on this system. Use four different commands.

Self-check:
- One command shows just your username.
- One shows who is currently logged in.
- One shows a more detailed view of logged-in users, what they are doing, and CPU usage.
- One shows your user ID, main group, and secondary groups.

When you have run all four commands and understand the differences
between their outputs,
press Enter to continue...
EOF

read -p ""

# ────────────────────────────────────────────────────────────────
# Task 2 – Temporary user
# ────────────────────────────────────────────────────────────────
clear
cat <<EOF
Task 2/9
─────────

Let's start with some Linux gymnastics...

1. Create a temporary user called 'tempuser' (with home dir).
2. Ops! Change its username to 'tmpuser', update its home directory as well.
3. Create a file owned by tmpuser, set it to: owner rw, group r, others nothing. 
(Use octal permissions mode always!).
4. Finally — delete tmpuser completely (including home).

When you have done ALL steps and seen the results,
press Enter...
EOF

read -p ""

# ────────────────────────────────────────────────────────────────
# Task 3 – Persistent user layla
# ────────────────────────────────────────────────────────────────
clear
cat <<EOF
Task 3/9
─────────

Now create another user: 'layla'.
Make sure she has  a home directory and proper bash shell.

Then — create three files inside her home directory with these permissions:

1. secret.txt     →  (only owner rw)
2. report.txt     →  (owner rw, group+others r)
3. script.sh      →  (owner rwx, group+others rx)

Self-check you MUST perform:
- List the files in long format to verify all is correct

Press Enter to continue...
EOF

read -p ""

# ────────────────────────────────────────────────────────────────
# Task 4 – Give layla sudo
# ────────────────────────────────────────────────────────────────
clear
cat <<EOF
Task 4/9
─────────

Layla will need to run privileged commands later this week.
Add her to the sudo (or wheel) group — the correct way."

Self-check:
- Check layla's groups → confirm sudo/wheel is there
- If missing → fix and check again

When layla is in the sudo group,
press Enter...
EOF

read -p ""

# ────────────────────────────────────────────────────────────────
# Task 5 – Read important /etc files
# ────────────────────────────────────────────────────────────────
clear
cat <<EOF
Task 5/9
─────────

Intern!

a) What pretty name does this OS/distribution have?
b) Print the names of the users who have a bash shell assigned (use pipes)
c) What makes the sudo/wheel groups special?


When you are ready, press Enter...
EOF

read -p ""

# ────────────────────────────────────────────────────────────────
# Task 6  - Filesystem Hierarchy & Find
# ────────────────────────────────────────────────────────────────
clear
cat <<EOF
Task 6/9
─────────
Navigate the filesystem like a senior engineer.

1. Find the path to the 'passwd' executable using a command (not guessing).
2. Create this structure in ~/sandbox/day1:
   logs/
   ├── app/
   └── system/
3. Inside logs/app, create 3 empty files: error.log, access.log, debug.log
4. Use ONE command to find all .log files in logs/ and delete them.

When you've completed all steps and verified,
press Enter...
EOF

read -p ""

# ────────────────────────────────────────────────────────────────
# Task 7  - Text Processing & Pipes
# ────────────────────────────────────────────────────────────────
clear
cat <<EOF
Task 7/9
─────────
Text wrangling without leaving the terminal.

First, run this to create test data:
  echo -e "nginx\napache\nnginx\nmysql\napache\nnginx" > ~/sandbox/day1/services.txt

Now:
1. Sort the file and remove duplicates (one pipeline).
2. Count how many lines contain 'nginx'.
3. Show lines that DON'T contain 'nginx'.
4. Replace all 'nginx' with 'openresty' in the output (don't modify file).

When your pipeline-fu is proven,
press Enter...
EOF

read -p ""

# ────────────────────────────────────────────────────────────────
# Task 8  - Process Management
# ────────────────────────────────────────────────────────────────
clear
cat <<EOF
Task 8/9
─────────
Master the running system.

1. Start a sleep process in background: sleep 300 &
2. List ALL running processes on the system (not just yours).
3. Find the PID of your sleep process using pgrep.
4. Politely terminate it (let it clean up).
5. Verify it's gone.

BONUS: Bring a background job to foreground, then send it back.

When processes obey your commands,
press Enter...
EOF

read -p ""

# ────────────────────────────────────────────────────────────────
# Task 9  - Service Management with systemd
# ────────────────────────────────────────────────────────────────
clear
cat <<EOF
Task 9/9
─────────
The final test: control the system itself.

1. Check if the cron service is running (systemctl).
2. View the last 20 log lines for cron (journalctl).
3. Stop the cron service (don't worry, we'll restart it).
4. Check status again — confirm it's stopped.
5. Start it again and verify.

Self-check:
- Service runs at boot? Check with is-enabled.
- What's the difference between stop and disable?

When you've mastered systemd,
press Enter...
EOF

read -p ""

cat <<EOF
═══════════════════════════════════════════════════════════════
     Kubecraft Daily Warm-up – Day 1 COMPLETE
═══════════════════════════════════════════════════════════════

You have proven you can:
✓ Navigate man pages and find commands
✓ Manage users, groups, and permissions
✓ Traverse the filesystem and wrangle text
✓ Control processes and services

Tomorrow: Networking, package management, and system monitoring.

Rest well, engineer.
EOF

# ────────────────────────────────────────────────────────────────
# DAY 2 – NETWORK & SYSTEM OPS
# ────────────────────────────────────────────────────────────────

read -p ""
clear
cat <<EOF
═══════════════════════════════════════════════════════════════
     DAY 2 – NETWORK OPERATIONS
═══════════════════════════════════════════════════════════════

Good morning. Today you're troubleshooting connectivity
and monitoring system health. No GUI tools allowed.

Press Enter to begin...
EOF

read -p ""

# ────────────────────────────────────────────────────────────────
# Day 2 Task 1 - Network Diagnostics
# ────────────────────────────────────────────────────────────────
clear
cat <<EOF
Day 2 – Task 1/6
─────────────────

Users report they can't reach the internet.

1. Check your IP address and network interfaces
2. Verify the default gateway is reachable
3. Test DNS resolution by pinging google.com (limit to 3 packets)
4. Check if port 443 is listening locally (HTTPS)
5. Download a file using curl (save it, don't display it)

When you've diagnosed connectivity,
press Enter...
EOF

read -p ""

# ────────────────────────────────────────────────────────────────
# Day 2 Task 2 - Log Analysis with Pipes
# ────────────────────────────────────────────────────────────────
clear
cat <<EOF
Day 2 – Task 2/6
─────────────────

Analyze this web server log pattern. First create test data:

  cat > /tmp/access.log <<'END'
  192.168.1.10 - GET /api/users 200
  192.168.1.11 - POST /api/login 401
  192.168.1.10 - GET /api/users 200
  192.168.1.12 - GET /api/admin 403
  192.168.1.11 - POST /api/login 401
  192.168.1.10 - GET /api/users 200
  END

Now:
1. Extract only the IP addresses (first column)
2. Sort them and count unique occurrences
3. Show only IPs that appear more than once
4. Filter for failed requests (401 or 403 codes) and count them

Use only pipes. No text editors.

When the attack pattern is clear,
press Enter...
EOF

read -p ""

# ────────────────────────────────────────────────────────────────
# Day 2 Task 3 - Package Management
# ────────────────────────────────────────────────────────────────
clear
cat <<EOF
Day 2 – Task 3/6
─────────────────

You need to deploy a monitoring stack.

1. Search for packages containing 'htop' or 'btop'
2. Check if htop is already installed
3. Install htop (or confirm it's present)
4. Verify the installation path using TWO different methods
5. Purge the package and confirm it's gone
6. Reinstall it (you'll need it later)

When your package management is surgical,
press Enter...
EOF

read -p ""

# ────────────────────────────────────────────────────────────────
# Day 2 Task 4 - Disk & Memory Monitoring
# ────────────────────────────────────────────────────────────────
clear
cat <<EOF
Day 2 – Task 4/6
─────────────────

The server is running slow. Investigate resource usage.

1. Check how long the system has been up
2. View memory usage in human-readable format
3. Find the 3 largest directories under /var/log
4. Check disk space on all mounted filesystems
5. Identify which filesystem is mounted on /boot (if any)

BONUS: Find files larger than 100MB in /home

When you know where the space went,
press Enter...
EOF

read -p ""

# ────────────────────────────────────────────────────────────────
# Day 2 Task 5 - Service Troubleshooting
# ────────────────────────────────────────────────────────────────
clear
cat <<EOF
Day 2 – Task 5/6
─────────────────

The SSH service stopped responding.

1. Check if ssh service is currently running
2. View the last 50 lines of SSH logs
3. Check if ssh is enabled to start at boot
4. Restart the ssh service safely
5. Verify it's listening on port 22
6. Follow SSH logs in real-time (Ctrl+C when done)

When the service is healthy and monitored,
press Enter...
EOF

read -p ""

# ────────────────────────────────────────────────────────────────
# Day 2 Task 6 - File Search & Permissions
# ────────────────────────────────────────────────────────────────
clear
cat <<EOF
Day 2 – Task 6/6
─────────────────

Security audit time. Find potential issues.

1. Find all files in /tmp owned by root (if accessible)
2. Find all .log files in /var modified in the last 7 days
3. Create a test file and set permissions so:
   - Owner can read/write
   - Group can only read
   - Others have no access
4. Create a directory with the same permissions
5. Test: Can you cd into the directory without execute permission?
   (This tests your understanding of directory vs file permissions)

When security makes sense,
press Enter...
EOF

read -p ""

cat <<EOF
═══════════════════════════════════════════════════════════════
     Kubecraft Daily Warm-up – Day 2 COMPLETE
═══════════════════════════════════════════════════════════════

You have proven you can:
✓ Diagnose network connectivity
✓ Analyze logs with pipeline precision
✓ Manage packages efficiently
✓ Monitor system resources
✓ Troubleshoot and control services
✓ Search files and understand permissions

You're no longer an intern. You're an engineer.

Tomorrow: Bash scripting and automation.
EOF
